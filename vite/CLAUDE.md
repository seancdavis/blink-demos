# Blink Platform Development Guide

This project is a social media platform built specifically for Netlify's platform. When working on this codebase, follow these patterns and conventions:

## Platform Architecture

### Netlify Functions (.mts files in netlify/functions/)

- Handle API endpoints and server-side logic
- Use TypeScript modules (.mts extension)
- Import utilities from `../../src/utils/index.mts`
- Always export a `config` object defining the path
- Return proper HTTP responses with status codes

### Netlify Edge Functions (.mts files in netlify/edge-functions/)

- Run at edge locations for performance
- Handle middleware-like functionality (auth, partials, feedback)
- Use `context.next()` to pass through to next handler
- Transform responses using HTMLRewriter when needed
- Define path configuration in `netlify.toml` to control for call order

### Data Storage with Netlify Blobs

- Use `@netlify/blobs` for data persistence
- Create stores with: `getStore({ name: 'StoreName', consistency: 'strong' })`
- Store JSON data: `store.set(key, data, { type: 'json' })`
- Retrieve data: `store.get(key, { type: 'json' })`
- List entries: `store.list()`

### Authentication System

- JWT-based auth using `jose` library
- Passwords hashed with `bcrypt`
- Session stored in httpOnly cookie `blink_session`
- JWT secret from `COOKIE_JWT_SECRET` environment variable
- Auth middleware in `edge-functions/auth.mts` handles page redirects for login/register pages
- Auth-gate system provides conditional content rendering based on authentication state

### Custom Templating System

#### Partial Components

- Use `<partial name="component-name">` tags in HTML
- Partials are rendered server-side by `netlify/edge-functions/partial.mts`
- Partial files stored in `src/partials/` as `.html` files
- Pass data via attributes: `<partial name="header" title="Page Title">`
- The `src/utils/partial-data.mts` file is auto-generated by `yarn build` - do not edit manually

#### Auth-Gate System

Use semantic auth wrappers to conditionally show content based on authentication state:

```html
<auth-gate>
  <is-authenticated>
    <!-- Content for logged-in users -->
    <!-- Receives data-username, data-avatar-src, data-user-id attributes -->
  </is-authenticated>
  <is-unauthenticated>
    <!-- Content for guest users -->
  </is-unauthenticated>
</auth-gate>
```

- Processed by `netlify/edge-functions/auth-gate.mts`
- Runs before partial processing
- `<is-authenticated>` elements get user data as data attributes
- Use JavaScript to populate templates with user data from data attributes

#### Special Elements

- `<feedback></feedback>` - Displays user feedback messages
- `<latest-posts></latest-posts>` - Dynamically loads posts

### Types and Data Models

Data schema definitions are located in `src/utils/types.mts`.

```typescript
type User = {
  id: string
  username: string
  password: string // bcrypt hashed
  avatarSrc: string
}

type Post = {
  id: string
  title: string
  content: string
  userId: string
  createdAt: string
}
```

### Utility Functions

- Import shared utilities from `src/utils/index.mts`
- Use `functionUtils()` for common function operations (redirects, feedback, cookies)
- Use `renderPartial()` for server-side partial rendering
- Use `getCurrentUser()` for auth checks

### File Upload System

- Avatar uploads handled by `user-upload-avatar.mts`
- Files stored in `/uploads/avatar/` directory
- Image resizing via Netlify's image transformation API
- Redirects in `netlify.toml` handle image optimization

### Environment Variables Required

- `COOKIE_JWT_SECRET` - Secret for JWT signing (generate with `npm run generate-secret`)
- `ADMIN_API_KEY` - Admin API key for backend access (when generating placeholder content)

### Development Commands

- `npm run dev` - Start Netlify Dev server
- `npm run build` - Build static assets and regenerate `partial-data.mts`
- `yarn build` - Alternative build command
- `npm run generate-secret` - Generate JWT secret

### Conventions

- All server-side code uses TypeScript with `.mts` extension
- Function names should be descriptive of their HTTP endpoint
- Use strong consistency for Netlify Blobs when data integrity matters
- Handle form submissions with proper validation and feedback
- Always set appropriate HTTP status codes
- Use UUID for all entity IDs

### 404 Error Handling Pattern

The platform uses a two-tiered approach for 404 handling that avoids edge function conflicts:

1. **Static 404 page** (`www/404.html`) - Netlify's default 404 handling serves this automatically
2. **Dynamic 404 partial** (`src/partials/not-found.html`) - Used by edge functions that need to show 404 content
3. **Shared content partial** (`src/partials/not-found-content.html`) - Contains the actual 404 content

Both the static page and dynamic partial reference the same `not-found-content` partial, ensuring consistent 404 messaging while allowing:
- Static files to be served normally by Netlify without edge function interference  
- Dynamic routes to show 404 content when needed
- Single source of truth for 404 content that's easy to maintain

This pattern prevents edge functions from interfering with static file serving while maintaining dynamic functionality where needed.

### Code Quality Standards

- NEVER duplicate functions across multiple files
- ALWAYS create utility functions for shared logic in `src/utils/`
- Follow existing patterns in the codebase
- Avoid edge function processing for static assets to prevent MIME type issues

### Security Patterns

- Validate all user inputs
- Hash passwords before storage
- Use httpOnly cookies for sessions
- Validate JWT tokens on protected routes
- Sanitize file uploads
- Use CSRF protection via sameSite cookie attributes

### Deployment

- Static files served from `www/` directory
- Build process copies assets and processes templates
- Netlify handles routing via `netlify.toml` configuration
- Edge functions run automatically based on path matching
